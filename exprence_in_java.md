
1.JMS的两种模式是那些；
JMS有两种通信方式 
P2P，点对点 方式和 
发布/订阅模式PUB,SUB 

点对点时，消息发送队列目的地（Queue），这个队列只有一个人可以接受到他对应的属于自己的消息，其他人员不会从队列得到与自己无关的消息。在消息未过期之前，消费者（接受者）可以在任意时间接受，消费者唯一，消费者可以在发送者之前，另外消费者在接受完后，必须反馈信息，表示信息被接受，否则JMS不认为消息被接受，（各种框架实现是自动的） 

发布／订阅模型，类似广播模式,发送消息给主题目的地（Topic），任何数量的消费订阅者可以从这个主题目的地来接收它们。 
不同的客户端订阅自己感兴趣的消息。每个消息都可以有多个订阅者,订阅者只能消费他们订阅之后出版的消息，即订阅者必须先运行，再等待生产者的运行，这和点对点类型有所差异。订阅者必须保持为活动状态才能使用这些消息,  即订阅者必须保持活动状态等待发布者发布的消息，如果订阅者在发布者发布消息之后才运行，则不能获得先前发布者发布的消息。

2.富客户端怎么更新；
自己设计类似ESB这样的企业数据总线应该有哪些功能；

1.SOA-面向服务的架构，可以说是一种架构风格，一种IT系统咨询和建设的方法论，也可以说是一种新的商业模式，SOA核心从SOA定义可以看到包括两个方面内容，一个是抽象出服务，这些服务满足离散，松耦合，可复用，自治，无状态等基本特征，一个是服务可以灵活的组装和编排，满足流程整合和业务变化的需要。所以SOA是一个很宽泛的概念，只要满足上面两条，实施思路是符合上面两条都是SOA的思路。

2.ESB-企业服务总线，是SOA技术架构落地的一个基本部件，现在我们说的SOA集成平台基本都需要有ESB组件，ESB最基本功能即是实现点对点集成到总线式集成的转换，在这个过程中实现了消息协议的转换和适配，数据传输，数据转换和映射，路由等基本功能。ESB发展从原有的EAI以消息中间件为核心转化到现在的以服务为核心，但是仍然支持消息转换和接入。

3.Web-Service是一种技术方面的标准，真正的跨语言，跨平台，提供了标准的服务定义，服务注册，服务接入和访问的方式。在讲SOA时候我们会谈到需要实现操作方法和操作数据的解耦，web service可以比较好的做到这一点，包括我们用wsdl进行方法层面的定义，用xsd进行传输数据的定义。但是Web-Service和SOA架构风格没有直接关系，Web-Service只是一种实现方法，不用Web-Service也可以实现SOA架构风格，这一点必须明确。否则一谈到SOA就简单理解为web service就犯大错误了。


Axis2框架和CXF框架，不管是服务提供方还是服务消费方，都建议选择CXF框架，axis框架不管是老版本，还是最新的版本，总是存在兼容性方面的各种问题，这个我们在实践中遇到过很多，现在已经只推荐使用CXF框架。


******3.系统架构设计；
表示层
表示层由UI（User Interface）和UI控制逻辑组成。

l         UI（User Interface）

UI是客户端的用户界面，负责从用户方接收命令，请求，数据，传递给业务层处理，然后将结果呈现出来。根据客户端的不同我们大体将应用程序分为BS（Browser-Server） 浏览器结构，CS（Client-Server）桌面客户端结构。

BS的优点是无需操心客户端，只需要部署维护好服务器即可。CS的优点在于强大的界面交互表达能力。RIA（Rich Internet Application）是为了融合这两种结构优点的一种技术，它依赖在客户端一次性安装一个通用解释器之后即获得强大的界面交互表达能力和无需部署具体客户端的方便性。具体的实现技术很多，例如微软的SmartClient， Avalon； Macromedia的Flex；以JS为基础的Bindows；Ajax等等很多。
    
 

l         UI控制逻辑

UI控制逻辑负责处理UI和业务层之间的数据交互，UI之间状态流程的控制，同时负责简单的数据验证和格式化等功能。具体的说在dotNet事件驱动的编程模型下，UI控制逻辑被自然的实现在了事件函数中，例如PageLoad事件函数，ButtonClick事件函数。在这些事件函数中，主要任务就是做UI控件与业务实体的数据交换与业务调用，但面对大量的数据交换工作量与维护量就成了最大的问题。而在复杂应用的系统中，状态与流程的管理是必须要考虑的因素，它们同样是业务逻辑的一部分，如果不加以封装的直接写在事件函数中将导致业务依赖表示层。下面分别讨论这两个问题。

 

1.         1.UI与业务实体之间的数据交互

此阶段负责数据交换的业务实体称为DTO（Data Transfer Object），处理输入时我们从UI控件的获得数据填入DTO再向下传播，处理输出时用户发出请求业务层会将数据以DTO的形式返出再赋给UI控件展现。因此需要一种方式来自动解决这样的来回赋值问题。遗憾的是dotNet下的不少控件虽然支持数据绑定但仍然没有一个现成完整的解决办法。我们可以自己设计一个Adapter按照某种映射关系来自动处理这样的绑定，这样的映射关系最好是UI控件与DTO属性的事先命名约定，以此种方式的约定作为映射关系无需增加任何配置文件和配置工作即可实现。

 

2.         2.状态与流程的管理

既然是业务逻辑的一部分就不应该耦合再表示层当中。MVC（Model-View-Controller）模式提供了实现这一目标的方法。Controller是整个方案的核心，它是一个流程管理器，来自UI所有的命令与数据经过Controller分发给业务层或其他UI，这样我们可以把流程，权限等逻辑单独封装，例如配置文件中，达到最大化的业务重用。dotNet下MVC的方案并不像Java下有那么多选择，目前有以下几种选择：

微软的UIPAB，它可以处理bs，cs下的流程跳转，可以使得相同的业务系统有webform和winform不同的展现方式。

开源的Mavrick.Net，它只适用于Asp.Net应用程序，它对流程，国际化，页面包装，xslt页面转换提供了很好的支持。

开源的Lattis，同样只适用于Asp.Net应用程序。

 

业务层
业务层封装了实际业务逻辑，包含数据验证，事物处理，权限处理等业务相关操作，是整个应用系统的核心。因此设计一个能够真实反映实际需要的业务层是非常必要的，我们将实际业务具体分为业务数据与业务操作两部分。

 

l         业务数据

业务数据又是业务逻辑的核心，最终业务数据将以一种固定的格式表现于内存中，在系统的各个层次间传输，充当DTO角色。表达业务数据的方式一般分为两种Table Model和Domain Model。

Table Model是将数据库中的表直接映射成为业务数据对象，这样的优点是适合于机器操作，ADO.NET直接提供了这种操作的便利，但对于复杂业务关系的表达就很不直观。只适合于业务需求与数据表对应关系很直接的需要快速开发的情况。通常我们选用Dataset或者强类型Dataset（Strong Typed Dataset），强类型Dataset支持编译时的类型检查，效率上要略高于普通Dataset。Dataset有很多方便的特性：无需自己编写维护类，支持序列化，数据副本保存，支持数据集合，对控件绑定支持效果好，微软提供了相应的生成工具以及持久方案。但缺点也是明显，复杂数据表现不直观，做为DTO在各个层次间传输，尤其是分布式环境，庞大的体积，相对缓慢的实例化对于性能造成很大压力。

Domain Model则是根据实际业务按照现实方式用OO思想建模，这样很适合业务复杂的系统。通常采用自定义数据实体（Custom Data Entity）方式表达。自定义数据实体，有着良好的性能，编译时的类型检查，数据表现方式非常直观符合实际业务的操作方式等优点，但需要自己定义维护类，在分布式环境下需要自己编写序列化方法。

综合各种因素考虑，虽然业务简单对应直接的系统我们以Table Model建模开发效率很高但难免保证系统日后不会变的复杂，因此出于复用性，扩展性，性能等方面选用Domain Model建模为佳。

 

l         业务操作

业务操作负责对业务数据进行各种业务相关的处理，例如验证，流向，整合，事物，权限等，但它不负责有关对数据源的操作。它与业务数据的关系设计有2种方式。

分离业务数据与业务操作，将业务数据单独封装到只有数据get，set的数据类中，这个数据类只充当DTO。将业务操作封装到独立的service类中与业务数据一起充当业务层。这样当系统不复杂的时候显的简单直观，而随着系统日益复杂，service类会变的杂乱，而将本身耦合紧密的数据与操作分离对于复用也是不利的因素。具体可参考Martin Fowler 的贫血的Domain Model一文，但我并不倾向于业务层直接访问数据源。

整合业务数据与业务操作，将业务数据与相关的业务操作封装在一起称为业务实体，业务实体作为统一的业务层为表示层提供服务，同时也负责作为DTO在各个层次间传输，我倾向于这样完整的Domain Model设计方式，每个业务实体都可以做为一个单独组件形式存在，对于组件化复用有着莫大的好处。

 

l         业务模块间的依赖

各个业务模块之间的依赖，有时候会是难以解决的问题，尤其是一些可以重复利用的业务组件，例如权限管理，邮件发送等等。管理好这些各种不同的业务组件是我们的目标，IoC容器为我们提供了最完美的方案，通过它将不同的模块注入到系统中我们可以在不知道这个组件存在的情况下调用它。但目前只有不成熟的Spring.Net一个选择，我们只有一声叹息，因此也就不多讨论了。

 

业务数据访问层
业务数据访问层是一个针对具体应用系统的专属层，它为业务层提供与数据源交互的最小操作方式，仅仅是业务层需要的数据访问接口，业务层完全依赖业务数据访问层所提供的服务。这些服务负责从业务层接收数据或返回业务实体，它屏蔽了实际业务数据与机器存储方式的差别。当然，数据层选用抽象的解决方案同样可以达到这个效果，但业务数据访问层最大的特点就是针对具体业务做抽象，而抽象的数据层访问方案是针对通用做抽象。往往业务中针对具体的设计生命力会变的更强，这样我们可以最大限度的保持了上层代码的复用性，当需要更换存储策略如果数据层访问差别太大，通过更换数据层无法解决问题的时候我们最多只需要更换业务数据访问层，而无需改变业务层。

 

业务数据访问层由DAO（Data Access Object）层和系统服务层两部分组成。DAO层为每个业务实体提供最基本的数据访问服务，系统服务层为系统全局提供与业务关系不大的通用数据访问服务，这两层处于系统中的同一个层次位置。

 

业务层与业务数据访问层关系图



 

 

数据层
数据层的宗旨就是为数据源提供一个可供外界访问的接口，我们应该选用一种能够提供数据源无关的抽象数据访问接口并通过在其下挂接各种不同的DataProviador来访问数据源的数据层组件，这样做便于移植到不同的数据源上。目前有以下3种数据层方案：

 

1.        1. 封装ADO.Net

这些数据访问组件都是基于ADO.Net的浅封装，它的优点在于封装层次低所以速度最快，我们可以手动组织sql语句用来适应复杂的操作以及个性的优化等。缺点是无法直接处理自定义数据实体方式的业务实体对象，需要将业务实体中的数据属性以参数形式传入传出。这样的方式虽然最为保险，但随着系统规模增大，开发效率，质量，，后期的维护，二次开发都变成尤为突出的问题，对开发人员的要求会变的越来越高。另外对于事物操作封装不是很好，无法提供声明性事物，经常会在业务层出现访问数据层的需要。这样的组件目前应用的很广泛，例如微软在EnterpriseLibrary中提供的DAAB（Data Access Application Block），还有以前的DAAB3.1。EnterpriseLibrary是个成熟的产品，包括了数据访问，异常，日志，缓存，加密，配置,安全等组件做为通用服务非常适合。

 

2.        2. OR-Mapping组件

ORM是最好的数据持久解决方案，它的优点在于能够以面向对象的方式操纵数据，因此可以直接处理自定义数据实体的业务对象，我们根本不用操心sql语句以及底层存储方式，这样极大的简化的代码提高了开发效率，对于日后维护扩展都带来极大的便利。缺点在于屏蔽了底层使得我们无法针对具体数据源做优化，而且对于复杂关联的sql操作有些力不从心，同时性能也差一些但辅助以缓存情况会好很多，而在dotNet下最大的问题就是没有一个成熟便宜的ORM产品供我们使用，全部都是beta版本和商业版本。这些版本或多或少都存在一些问题，以至于真正应用中需要经过仔细考察。例如NHibernate，Gentle.Net，XPO，Grove.Net等等非常多。

 

3.        3. DataMapper（SqlMapper）

SqlMapper为以上两种方式提供了一个折中的选择，它可以以面向对象的方式直接处理自定义数据实体的业务对象，同时可以根据与数据源与业务实体的映射关系执行手写的sql语句，这样完全使得我们可以针对具体数据源做优化，对于复杂操作同样可以胜任。目前只有iBatis.Net一个产品，它是一个java移至的开源项目，已经比较成熟，可以在无需编译的情况下随意替换DAO。


集群中怎么控制session；
当实现session管理器的时候，有两个必须要解决的核心问题。首先，如何创建集群环境下高可用的session，要求能够可靠并高效地存储数据。其次，不管请求是HTTP、WebSocket、AMQP还是其他的协议，对于传入的请求该如何确定该用哪个session实例。实质上，关键问题在于：在发起请求的协议上，session id该如何进行传输？

Spring Session认为第一个问题，也就是在高可用可扩展的集群中存储数据已经通过各种数据存储方案得到了解决，如Redis、GemFire以及Apache Geode等等，因此，Spring Session定义了一组标准的接口，可以通过实现这些接口间接访问底层的数据存储。Spring Session定义了如下核心接口：Session、ExpiringSession以及SessionRepository，针对不同的数据存储，它们需要分别实现。


怎么样知道java存中是哪一些模块消耗内存比较多；
请看一下一个时间的Java参数配置：（服务器：Linux 64Bit，8Core×16G）
 
 JAVA_OPTS="$JAVA_OPTS -server -Xms3G -Xmx3G -Xss256k -XX:PermSize=128m -XX:MaxPermSize=128m -XX:+UseParallelOldGC -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/aaa/dump -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:/usr/aaa/dump/heap_trace.txt -XX:NewSize=1G -XX:MaxNewSize=1G"
经过观察该配置非常稳定，每次普通GC的时间在10ms左右，Full GC基本不发生，或隔很长很长的时间才发生一次
通过分析dump文件可以发现，每个1小时都会发生一次Full GC，经过多方求证，只要在JVM中开启了JMX服务，JMX将会1小时执行一次Full GC以清除引用，关于这点请参考附件文档。

应用服务器的参数调整。 


数据库连接池怎么实现的  还有struts怎么实现映射的?
数据库连接池的最小连接数和最大连接数的设置要考虑到下列几个因素：
　　1) 最小连接数是连接池一直保持的数据库连接，所以如果应用程序对数据库连接的使用量不大，将会有大量的数据库连接资源被浪费；
　　2) 最大连接数是连接池能申请的最大连接数，如果数据库连接请求超过此数，后面的数据库连接请求将被加入到等待队列中，这会影响之后的数据库操作。
　　3) 如果最小连接数与最大连接数相差太大，那么最先的连接请求将会获利，之后超过最小连接数量的连接请求等价于建立一个新的数据库连接。不过，这些大于最小连接数的数据库连接在使用完不会马上被释放，它将被放到连接池中等待重复使用或是空闲超时后被释放。
目前常用的连接池有：C3P0、DBCP、Proxool
网上的评价是：
C3P0比较耗费资源，效率方面可能要低一点。
DBCP在实践中存在BUG，在某些种情会产生很多空连接不能释放，Hibernate3.0已经放弃了对其的支持。
Proxool的负面评价较少，现在比较推荐它，而且它还提供即时监控连接池状态的功能，便于发现连接泄漏的情况。

------------------------------------------------------------------------------------------
struts2本身就是这种机制,如果楼主可以使用struts2的话就直接用strut2 就可以了。原理的话就是：系统启动时会读取struts.xml文件，将里面配置的method的name和class及result name、value读取到一个map数据结构中，收到客户端的请求，会产生一个action代理类，由代理类进行前期的拦截器处理，随后交给actionDispacher，该类去根据前面读取struts2.xml的map去反射到相应的方法中。
如果楼主不使用struts2的话，可以封装一个继承HttpServlet的基类，在该基类中解析请求的URL，根据url中的action=new反射到子类的new 方法中就可以了。不过HttpServlet是单实例多线程的处理思想，楼主注意处理好同步的问题。

主要关心源码和实现原理的问题  


Http的缓存方式有几种 JVM调优 碰到的技术难题有哪些如何解决的 如何实现动态配置系统，例如disconf 

HTTP 控制缓存主要有一下几种方式：

Expires
Cache-Control
Last-Modified/If-Modified-Since
Etag/If-None-Match



